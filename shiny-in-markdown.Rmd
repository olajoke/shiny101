---
title: "Shiny Applications for Beginners"
author: "Olajoke"
date: "2023-01-13"
output: html_document
runtime: shiny
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This R Markdown document is made interactive using Shiny. Unlike the more traditional workflow of creating static reports, you can now create documents that allow your readers to change the assumptions underlying your analysis and see the results immediately.

To learn more, see [Interactive Documents](http://rmarkdown.rstudio.com/authoring_shiny.html).

## Inputs and Outputs

You can embed Shiny inputs and outputs in your document. Outputs are automatically updated whenever inputs change. This demonstrates how a standard R plot can be made interactive by wrapping it in the Shiny `renderPlot` function. The `selectInput` and `sliderInput` functions create the input widgets used to drive the plot.

```{r}
library(shiny)
```

```{r eruptions, echo=FALSE}
inputPanel(
  selectInput("n_breaks",
    label = "Number of bins:",
    choices = c(10, 20, 35, 50), selected = 20
  ),
  sliderInput("bw_adjust",
    label = "Bandwidth adjustment:",
    min = 0.2, max = 2, value = 1, step = 0.2
  )
)

renderPlot({
  hist(faithful$eruptions,
    probability = TRUE, breaks = as.numeric(input$n_breaks),
    xlab = "Duration (minutes)", main = "Geyser eruption duration"
  )

  dens <- density(faithful$eruptions, adjust = input$bw_adjust)
  lines(dens, col = "blue")
})
```

```{r echo=FALSE}
ui <- fluidPage(
  selectInput("dataset", label = "Dataset", choices = ls("package:datasets")),
  verbatimTextOutput("summary"),
  tableOutput("table")
)

server <- function(input, output, session) {
  output$summary <- renderPrint({
    dataset <- get(input$dataset, "package:datasets")
    summary(dataset)
  })

  output$table <- renderTable({
    dataset <- get(input$dataset, "package:datasets")
    dataset
  })
}
shinyApp(ui, server)
```

```{r echo=FALSE}
library(shiny)

ui <- fluidPage(
  sliderInput("x", label = "If x is", min = 1, max = 50, value = 30),
  sliderInput("y", label = "If y is", min = 1, max = 50, value = 5),
  textOutput("product")
)

server <- function(input, output, session) {
  output$product <- renderText({
    paste0("then x times y is ", as.character(input$x * input$y))
  })
}

shinyApp(ui, server)
```

```{r echo=FALSE}
library(shiny)
library(ggplot2)

datasets <- c("economics", "faithful", "seals")
ui <- fluidPage(
  selectInput("dataset", "Dataset", choices = datasets),
  verbatimTextOutput("summary"),
  plotOutput("plot")
)

server <- function(input, output, session) {
  dataset <- reactive({
    get(input$dataset, "package:ggplot2")
  })

  output$summmary <- renderPrint({
    summary(dataset())
  })

  output$plot <- renderPlot(
    {
      plot(dataset())
    },
    res = 96
  )
}

shinyApp(ui, server)
```

```{r}
ui <- fluidPage(
  dataTableOutput("table")
)
server <- function(input, output, session) {
  output$table <- renderDataTable(mtcars, options = list(pageLength = 5))
}

shinyApp(ui, server)
```

## Embedded Application

It's also possible to embed an entire Shiny application within an R Markdown document using the `shinyAppDir` function. This example embeds a Shiny application located in another directory:

```{r tabsets, echo=FALSE}
shinyAppDir(
  system.file("examples/06_tabsets", package = "shiny"),
  options = list(
    width = "100%", height = 550
  )
)
```

Note the use of the `height` parameter to determine how much vertical space the embedded application should occupy.

You can also use the `shinyApp` function to define an application inline rather then in an external directory.

In all of R code chunks above the `echo = FALSE` attribute is used. This is to prevent the R code within the chunk from rendering in the document alongside the Shiny components.

```{r}
```

### Server Function

Good to know!

> ...
>
> Just like any other R function, when the server function is called it creates a new local environment that is independent of every other invocation of the function. This allows each session to have a unique state, as well as isolating the variables created *inside* the function. This is why almost all of the reactive programming you'll do in Shiny will be inside the server function.
>
> <https://mastering-shiny.org/basic-reactivity.html>

#### Input Argument

> One more important thing about `input`: it's selective about who is allowed to read it. To read from an `input`, you must be in a **reactive context** created by a function like [`renderText()`](https://rdrr.io/pkg/shiny/man/renderPrint.html) or [`reactive()`](https://rdrr.io/pkg/shiny/man/reactive.html).

#### Output Argument

> You always use the `output` object in concert with a `render` function, as in the following simple example:
>
> ``` r
> ui <- fluidPage(
>   textOutput("greeting")
> )
>
> server <- function(input, output, session) {
>   output$greeting <- renderText("Hello human!")
> }
> ```

The render function does two things:

-   It sets up a special reactive context that automatically tracks what inputs the output uses.

-   It converts the output of your R code into HTML suitable for display on a web page.

Like the `input`, the `output` is picky about how you use it. You'll get an error if:

-   You forget the `render` function

    ``` r
    server <- function(input, output, session) {
      output$greeting <- "Hello human"
    }
    shinyApp(ui, server)
    #> Error: Unexpected character object for output$greeting
    #> â„¹ Did you forget to use a render function?
    ```

-   You attempt to read from an output.

    ``` r
    server <- function(input, output, session) {
      message("The greeting is ", output$greeting)
    }
    shinyApp(ui, server)
    #> Error: Reading from shinyoutput object is not allowed.
    ```

### Reactive Programming

> Reactivity means that outputs automatically update as inputs change.

### Declarative vs Imperative

-   In **imperative** programming, you issue a specific command and it's carried out immediately. This is the style of programming you're used to in your analysis scripts: you command R to load your data, transform it, visualise it, and save the results to disk. **Imperative** code is assertive.

-   In **declarative** programming, you express higher-level goals or describe important constraints, and rely on someone else to decide how and/or when to translate that into action. This is the style of programming you use in Shiny. **declarative** code is passive-aggressive.

### Laziness

> If you're working on a Shiny app and you just can't figure out why your code never gets run, double check that your UI and server functions are using the same identifiers.

### Reactive Graph

Codes are run when need in shiny environment, therefore reading a code from top to bottom does not apply. To understand the order of execution one may need to look at the **reactive graph**, which describes how inputs and outputs are connected.

## Shortcuts Keys

1.  Type `shinyapp` then press `Shift` + `Tab` to insert the Shiny app snippet.

    ``` r
    library(shiny)
    ui <- fluidPage(
    )
    server <- function(input, output, session) {
    }
    shinyApp(ui, server)
    ```

2.  To run your app `Cmd/Ctrl` + `Shift` + `Enter`
